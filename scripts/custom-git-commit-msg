#!/usr/bin/perl

use strict;
use warnings;
use utf8;

#   Variables
our $VERSION    =  0.2;

our %changes    = (
    'added'     =>  [],
    'modified'  =>  [],
    'deleted'   =>  []
);
our $begin_line =   qr/to be committed/;
our $end_line   =   qr/not staged for commit/;
our $original   =   '';
our %labels = (
    'added'     =>  <<EOF,
== Nuevos archivos == 

EOF
    'modified'  =>  <<EOF,
== Modificados ==

EOF
    'deleted'   =>  <<EOF,
== Borrados == 

EOF
);

#   Main loop: filter
our $state = undef;
while (my $line = <STDIN>) {
    # backup original line and discard not commented lines
    $original .= $line;
    next if $line !~ m{^#};

    # Checking state
    if (not defined $state) {
        if ($line =~ m{$begin_line}) {
            $state = 'search';
        }
        elsif ($line =~ m{$end_line}) {
            $state = 'discard';
        }
        next;
    }
    elsif ($state eq 'search' and $line =~ m{$end_line}) {
        $state = 'discard';
    }

    if ($line =~ m{#\s+new file:\s+(.+)$}) {
        push(@{$changes{added}}, $1);
    }
    elsif ($line =~ m{#\s+modified:\s+(.+)$}) {
        push(@{$changes{modified}}, $1);
    }
    elsif ($line =~ m{#\s+deleted:\s+(.+)$}) {
        push(@{$changes{deleted}}, $1);
    }
}

#  build the final commit message
_dump_formatted_changes( \*STDOUT, \%changes );

#   with the original input
print STDOUT $original;

1;

sub _dump_formatted_changes {
    my  $output     =   shift;
    my  $changes    =   shift;

    foreach my $changetype (qw(added modified deleted)) {
        if (scalar(@{$changes->{$changetype}}) > 0) {
            print $output $labels{$changetype};
        
            _dump_file_list( $output, $changes->{$changetype} );
        }
    }

    return;
}    

sub _dump_file_list {
    my  $output     =   shift;
    my  $file_list  =   shift;

    foreach my $file (@{ $file_list }) {
        printf $output "%s:\n\n", $file;
    }

    return;
}

